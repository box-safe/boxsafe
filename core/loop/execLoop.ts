/**
 * @fileoverview
 * Implements an iterative agent loop that coordinates LLM code generation,
 * execution, and validation until a successful result is achieved.
 *
 * @description
 * The loop follows a deterministic pipeline:
 * 1. Send feedback to an LLM instance.
 * 2. Read the generated markdown artifact.
 * 3. Extract language-specific code blocks.
 * 4. Write the extracted code to an output file.
 * 5. Execute the output via a system command.
 * 6. Validate execution results using a waterfall validator.
 * 7. Generate structured feedback on failure and retry.
 *
 * The process repeats until validation succeeds.
 *
 * This module is designed for automated agent workflows.
 * Logs and artifacts are intended for machine consumption, not humans.
 *
 * @module core/loop
 */

import { readFile, writeFile, rename } from "node:fs/promises";
import { pathToCode } from "@core/paths/paths";
import { createLLM } from "@ai/provider";
import { runLLM } from "@ai/caller";
import { LService, LModel } from "@ai/label";
import { extractCode } from "@/util/extractCode";
import type { CommandRun } from "@/types";
import { execode } from "@core/cmd/execode";
import { ANSI } from "@util/ANSI";
import { waterfall } from "@core/loop/waterfall";
import { createNavigator } from "@core/navigate";
import type { Navigator } from "@core/navigate";
import fs from 'node:fs';
import path from 'node:path';
import { runVersionControl } from '@core/loop/git';

interface LoopOptions {
  service: LService;
  model: LModel;
  initialPrompt: string;
  cmd: CommandRun;
  lang: string;
  pathOutput: string;
  // optional safety / configuration
  maxIterations?: number;
  // number of iterations to run the main loop (overrides maxIterations when provided)
  limit?: number;
  signal?: AbortSignal;
  // allow a custom path for the model-generated markdown (defaults to `pathToCode`)
  pathGeneratedMarkdown?: string;
  // optional navigator instance for file system operations within the workspace
  navigator?: Navigator;
  // workspace path for creating navigator if not provided
  workspace?: string;
  logger?: {
    info: (...args: any[]) => void;
    warn: (...args: any[]) => void;
    error: (...args: any[]) => void;
    debug?: (...args: any[]) => void;
  };
}

export interface LoopResult {
  ok: boolean;
  iterations: number;
  verdict?: any;
  artifacts?: { outputFile?: string };
  navigator?: Navigator | null; // Navigator instance available for reference after loop (null if not initialized)
}

/**
 * Create a navigator instance with the given workspace.
 * Useful for creating navigator before loop or injecting custom config.
 * @param workspace - path to workspace directory
 * @param maxFileSize - optional maximum file size in bytes (default 10MB)
 * @returns Navigator instance
 */
export const createWorkspaceNavigator = (workspace: string, maxFileSize?: number): Navigator => {
  return createNavigator({
    workspace,
    maxFileSize: maxFileSize ?? 10 * 1024 * 1024,
  });
};

// Reads the markdown file generated by the model (path injectable for testability)
const readMarkdown = async (markdownPath: string) => {
  return readFile(markdownPath, "utf-8");
};

export const loop = async (
  {
    service,
    model,
    initialPrompt,
    cmd,
    lang,
    pathOutput,
    maxIterations = 10,
    limit,
    signal,
    pathGeneratedMarkdown = pathToCode,
    navigator: injectedNavigator,
    workspace,
    logger,
  } : LoopOptions
): Promise<LoopResult> => {
  const llm = createLLM(service, model);
  const log = logger ?? console;

  // Version control: configurable commit messages and behavior
  // Top-level variable for the 'before' commit message so it's easy to find and change.
  const BEFORE_COMMIT_MESSAGE = process.env.BOXSAFE_BEFORE_MSG ?? 'save agent';

  // Load user's boxsafe config if present
  const configPath = path.resolve(process.cwd(), 'boxsafe.config.json');
  let boxConfig: any = {};
  try {
    if (fs.existsSync(configPath)) {
      const raw = fs.readFileSync(configPath, 'utf-8');
      boxConfig = JSON.parse(raw);
    }
  } catch (err) {
    boxConfig = {};
  }
  

  const vcBefore = Boolean(boxConfig.project?.versionControl?.before ?? false);
  const vcAfter = Boolean(boxConfig.project?.versionControl?.after ?? false);
  const vcGenerateNotes = Boolean(boxConfig.project?.versionControl?.generateNotes ?? false);

  // If configured, run a one-time 'before' commit when the agent starts
  if (vcBefore) {
    try {
      await runVersionControl({ repoPath: workspace ?? process.cwd(), commitMessage: BEFORE_COMMIT_MESSAGE, autoPush: false, generateNotes: vcGenerateNotes });
      log.info(`${ANSI.Cyan}[VersionControl]${ANSI.Reset} before-commit completed`);
    } catch (err: any) {
      log.warn(`${ANSI.Yellow}[VersionControl]${ANSI.Reset} before-commit failed: ${err?.message ?? err}`);
    }
  }

  // Determine effective workspace (from arg, config or cwd) and initialize navigator
  const effectiveWorkspace = workspace ?? boxConfig.project?.workspace ?? process.cwd();
  const navigator = injectedNavigator ?? (effectiveWorkspace ? createNavigator({ workspace: effectiveWorkspace }) : null);

  const effectiveLimit = typeof limit === "number" ? limit : maxIterations;
  let feedback = initialPrompt;

  const sleep = (ms: number) => new Promise((r) => setTimeout(r, ms));

  for (limit = 1; limit <= effectiveLimit; limit++) {
    if (signal?.aborted) {
      log.error(`${ANSI.Red}[Agent]${ANSI.Reset} aborted`);
      return { ok: false, iterations: limit, navigator };
    }

    log.info(`${ANSI.Cyan}[Agent]${ANSI.Reset} iteration ${limit}`);

    // Run the LLM with the current feedback (with a small retry/backoff for transient LLM errors)
    let llmAttempts = 0;
    const maxLlmAttempts = 3;
    while (true) {
      try {
        if (signal?.aborted) throw new Error("Aborted");
        // Ensure the model (or mock) receives an explicit instruction about
        // the requested code language so we consistently get the correct
        // fenced block back. This helps the mock and real LLMs produce the
        // expected language output regardless of previous feedback text.
        const promptToSend = `${feedback}\n\nRespond ONLY with a single code block in the language: ${lang}`;
        await runLLM(promptToSend, llm);
        break;
      } catch (err: any) {
        llmAttempts++;
        log.error(`${ANSI.Red}[LLM Runner]${ANSI.Reset}`, err?.message ?? err);
        if (llmAttempts >= maxLlmAttempts) {
          return { ok: false, iterations: limit, navigator };
        }
        const backoff = 200 * Math.pow(2, llmAttempts - 1);
        await sleep(backoff);
      }
    }

    // Read the generated markdown
    let markdown: string;
    try {
      if (signal?.aborted) throw new Error("Aborted");
      markdown = await readMarkdown(pathGeneratedMarkdown);
    } catch (err: any) {
      log.error(`${ANSI.Red}[ReadMarkdown]${ANSI.Reset}`, err?.message ?? err);
      // give feedback to the model and retry
      feedback = "Could not read the generated markdown. Please emit markdown artifact.";
      continue;
    }

    // Extract code blocks for the target language
    let codeBlocks: string[];
    try {
      if (signal?.aborted) throw new Error("Aborted");
      codeBlocks = await extractCode(markdown, lang, {
        throwOnNotFound: true,
      });
    } catch (err: any) {
      log.warn(`${ANSI.Yellow}[ExtractCode]${ANSI.Reset}`, err?.message ?? err);
      feedback = "No code blocks were found. Generate valid code for the requested language.";
      continue;
    }

    // --- Tool call handling: detect JSON tool blocks in the generated markdown ---
    try {
      // look for fenced JSON blocks that contain a top-level "tool" property
      const jsonFenceRe = /```(?:json|json-tool)?\s*({[\s\S]*?})\s*```/g;
      let m:any;
      while ((m = jsonFenceRe.exec(markdown)) !== null) {
        try {
          const obj = JSON.parse(m[1]);
          if (obj && typeof obj === 'object' && obj.tool) {
            log.info(`${ANSI.Cyan}[Tool]${ANSI.Reset} detected tool call: ${obj.tool}`);
            if (obj.tool === 'navigate') {
              if (!navigator) {
                log.warn(`${ANSI.Yellow}[Tool]${ANSI.Reset} navigate requested but navigator is not initialized`);
              } else {
                // Map operation to navigator methods
                const params = obj.params ?? {};
                const op = params.op;
                let toolRes: any = null;
                try {
                  if (op === 'write') {
                    toolRes = await navigator.writeFile(params.path, params.content ?? '', params.writeOptions);
                  } else if (op === 'mkdir') {
                    toolRes = await navigator.createDirectory(params.path, params.mkdirOptions);
                  } else if (op === 'delete') {
                    toolRes = await navigator.delete(params.path, params.deleteOptions);
                  } else if (op === 'read') {
                    toolRes = await navigator.readFile(params.path);
                  } else if (op === 'list') {
                    toolRes = await navigator.listDirectory(params.path ?? '.');
                  } else if (op === 'stat') {
                    toolRes = await navigator.getMetadata(params.path);
                  } else {
                    log.warn(`${ANSI.Yellow}[Tool]${ANSI.Reset} unknown navigate op: ${op}`);
                  }
                } catch (innerErr: any) {
                  log.error(`${ANSI.Red}[Tool]${ANSI.Reset} navigate execution error: ${innerErr?.message ?? innerErr}`);
                }

                log.info(`${ANSI.Cyan}[Tool]${ANSI.Reset} navigate result: ${JSON.stringify(toolRes ?? { ok: false })}`);
              }
            } else {
              log.warn(`${ANSI.Yellow}[Tool]${ANSI.Reset} unhandled tool: ${String(obj.tool)}`);
            }
          }
        } catch (jsonErr: any) {
          // ignore JSON parse errors for other fences
        }
      }
    } catch (toolErr: any) {
      log.warn(`${ANSI.Yellow}[Tool]${ANSI.Reset} tool parsing failed: ${toolErr?.message ?? toolErr}`);
    }

    if (!codeBlocks || codeBlocks.length === 0) {
      feedback = "No code blocks were found. Generate valid code.";
      continue;
    }

    // Atomic write: write to temp and rename
    const tmpPath = `${pathOutput}.tmp`;
    try {
      if (signal?.aborted) throw new Error("Aborted");
      await writeFile(tmpPath, codeBlocks.join("\n\n"), "utf-8");
      await rename(tmpPath, pathOutput);
    } catch (err: any) {
      log.error(`${ANSI.Red}[WriteFile]${ANSI.Reset}`, err?.message ?? err);
      feedback = "Failed to write output file. Ensure filesystem permissions are correct.";
      continue;
    }

    // Execute the generated code
    let execResult: any;
    try {
      if (signal?.aborted) throw new Error("Aborted");
      // If caller left the default `echo OK`, automatically run the
      // generated output file according to the requested language so the
      // loop actually executes the produced artifact.
      let execCmd = cmd;
      if (typeof cmd === 'string' && cmd === 'echo OK') {
        if (lang === 'ts') execCmd = `ts-node ${pathOutput}`;
        else if (lang === 'js') execCmd = `node ${pathOutput}`;
        else if (lang === 'py' || lang === 'python') execCmd = `python ${pathOutput}`;
        else if (lang === 'sh' || lang === 'bash' || lang === 'shell') execCmd = `bash ${pathOutput}`;
        else execCmd = `${pathOutput}`;

        log.info(`${ANSI.Cyan}[Execode]${ANSI.Reset} auto-executing generated file with: ${execCmd}`);
      }

      // If executing JS: check for CommonJS usage (require) and project type=module.
      try {
        if (lang === 'js' && execCmd.startsWith('node ')) {
          const pkgPath = path.join(process.cwd(), 'package.json');
          let isModuleType = false;
          try {
            if (fs.existsSync(pkgPath)) {
              const pkgRaw = fs.readFileSync(pkgPath, 'utf-8');
              const pkg = JSON.parse(pkgRaw);
              isModuleType = pkg.type === 'module';
            }
          } catch (e) {
            isModuleType = false;
          }

          const outContent = fs.readFileSync(pathOutput, 'utf-8');
          if (isModuleType && /\brequire\s*\(/.test(outContent) && path.extname(pathOutput) === '.js') {
            const newPath = pathOutput.replace(/\.js$/, '.cjs');
            try {
              await fs.promises.rename(pathOutput, newPath);
              execCmd = `node ${newPath}`;
              log.info(`${ANSI.Cyan}[Execode]${ANSI.Reset} renamed output to ${newPath} for CommonJS compatibility`);
            } catch (e) {
              log.warn(`${ANSI.Yellow}[Execode]${ANSI.Reset} failed to rename file for CJS: ${e?.message ?? e}`);
            }
          }
        }
      } catch (e) {
        // non-fatal
      }

      execResult = await execode(execCmd);
    } catch (err: any) {
      log.error(`${ANSI.Red}[Execode]${ANSI.Reset}`, err?.message ?? err);
      feedback = `Execution failed: ${err?.message ?? "unknown"}`;
      continue;
    }

    // Debug: log exec output and the written artifact to diagnose failures
    try {
      log.info(`${ANSI.Cyan}[Execode]${ANSI.Reset} exit=${execResult.exitCode}`);
      log.info(`${ANSI.Cyan}[Execode]${ANSI.Reset} stdout=${String(execResult.stdout).slice(0,1000)}`);
      log.info(`${ANSI.Cyan}[Execode]${ANSI.Reset} stderr=${String(execResult.stderr).slice(0,1000)}`);
      try {
        const outFile = await readFile(pathOutput, 'utf-8');
        log.info(`${ANSI.Cyan}[OutputFile]${ANSI.Reset} ${outFile.slice(0,1000)}`);
      } catch (err: any) {
        log.info(`${ANSI.Cyan}[OutputFile]${ANSI.Reset} could not read output file: ${err?.message ?? err}`);
      }
    } catch (errAny) {
      // swallow logging errors
    }

    // Validate execution results using the waterfall pipeline
    let verdict: any;
    try {
      if (signal?.aborted) throw new Error("Aborted");
      verdict = await waterfall({
        exec: execResult,
        artifacts: {
          outputFile: pathOutput,
        },
      });
    } catch (err: any) {
      log.error(`${ANSI.Red}[Waterfall]${ANSI.Reset}`, err?.message ?? err);
      feedback = `Validation pipeline failed: ${err?.message ?? "unknown"}`;
      continue;
    }

    // Stop if the execution is valid
    if (verdict?.ok) {
      log.info(`${ANSI.Green}[Agent]${ANSI.Reset} success after ${limit} iterations`);

      // After-success versioning (commit explaining what was done)
      if (vcAfter) {
        const afterMessage = `agent: completed successfully in ${limit} iterations`;
        try {
          await runVersionControl({ repoPath: workspace ?? process.cwd(), commitMessage: afterMessage, autoPush: false, generateNotes: vcGenerateNotes });
          log.info(`${ANSI.Cyan}[VersionControl]${ANSI.Reset} after-commit completed`);
        } catch (err: any) {
          log.warn(`${ANSI.Yellow}[VersionControl]${ANSI.Reset} after-commit failed: ${err?.message ?? err}`);
        }
      }

      return { ok: true, iterations: limit, verdict, artifacts: { outputFile: pathOutput }, navigator };
    }

    // Build structured feedback for the next iteration
    feedback = `Layer: ${verdict?.layer ?? "unknown"}\nReason: ${verdict?.reason ?? "unknown"}\nDetails: ${verdict?.details ?? "n/a"}`;

    log.warn(`${ANSI.Yellow}[Waterfall]${ANSI.Reset} failed at ${verdict?.layer ?? "unknown"}`);
  }

  // If the loop completes without a successful verdict
  return { ok: false, iterations: limit, navigator };
};
